#pragma config(Sensor, S1,     sIr1,           sensorEV3_IRSensor, modeEV3IR_Seeker)
#pragma config(Sensor, S2,     sDis,           sensorEV3_GenericI2C, modeEV3I2C_9V)
#pragma config(Sensor, S3,     sDisBack,       sensorEV3_IRSensor)
#pragma config(Sensor, S4,     sIr2,           sensorEV3_IRSensor, modeEV3IR_Seeker)
#pragma config(Motor,  motorA,          mA,            tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          mB,            tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          mOut,          tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          mDoor,         tmotorEV3_Medium, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#pragma config(Motor,  motorC,          mOut,          tmotorEV3_Large, PIDControl, encoder)
//#pragma config(Motor,  motorD,          mDoor,         tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#include "mindsensors-ev3smux.h"
tMSEV3 muxedSensor[1];
tEV3SensorTypeMode typeMode[1] = {infraRedProximity};
int e = 0;
int u = 0;
int const k1 = -1;
int it = 0;
int const distocon = 20;
int apple = 0; //apple check: 0-no apple, 1- apple
//int disS = 0;
int disS2 = 0;
//int n = 0;//distance check flag: 0- stop, 1 - go, 2 - go back
int const v1 = 50; // speed main
//int	const v2 = 30; // speed slow
int const dis2 = 10 ;//distance to collector min
int const dis1 = 20;//distance to collector max
int const disA = 10;
float const k = 0.3;//slow speed value
int nForOut=0;
//---------------------------------------------------------------------------------------------------------------------------------------------
int getDistancefront ()
{
	readSensor(&muxedSensor[0]);
	sleep(50);
	int y = muxedSensor[0].distance;
	int n = 0;
	if(y < dis1)
	{
		if (y < dis2)
		{
			n = 2;
		}
		else
		{
			n = 0;
		}
	}
	else
	{
		playSound(soundBeepBeep);
		n = 1;
	}
	displayTextLine(12, "n=%d", n);
	return n;
}
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
task out()
{
	while (nForOut == 0)
	{
		while (nMotorEncoder[mOut]>-10)
		{
			motor[mOut]= -100;

			sleep(1);
		}
		sleep(10);
	}
}
//---------------------------------------------------------------------------------------------------------------------------------------------
task apples()
{

	while(true)
	{
		disS2 = 0 ; //SensorValue[sApple];
		displayTextLine(6, "apple =%d",apple);
		displayTextLine(7,"dis to app =%d",disS2);
		if (0<disA)
		{
			sleep(2000);
			if (0<disA) // SensorValue[sApple]
			{
				apple = 1;
			}
		}
		else
		{
			apple = 0;
		}
	}
}
//---------------------------------------------------------------------------------------------------------------------------------------------
void down ()
{
	nMotorEncoder[mOut]=0;
	while (nMotorEncoder[mOut]>-550)
	{
		motor[mOut]= -100;
		sleep(1);
	}
	motor[mOut]=0;
}
//---------------------------------------------------------------------------------------------------------------------------------------------
void up ()
{
	nMotorEncoder[mOut]=0;
	while (nMotorEncoder[mOut]<550)
	{
		motor[mOut]= 100;
		sleep(1);
	}
	motor[mOut]=0;
}
//---------------------------------------------------------------------------------------------------------------------------------------------
void doorOp()
{
	nMotorEncoder[mDoor]=0;
	while(nMotorEncoder[mDoor]<50)
	{
		motor[mDoor]=20;
		sleep(1);
	}
	motor[mDoor]=0;
}
//---------------------------------------------------------------------------------------------------------------------------------------------
void doorClo()
{
	nMotorEncoder[mDoor]=0;
	while(nMotorEncoder[mDoor]>-50)
	{
		motor[mDoor]=-20;
		sleep(1);
	}
	motor[mDoor]=0;
}

//---------------------------------------------------------------------------------------------------------------------------------------------
task main()
{
	nForOut=1;
	startTask(out);
	startTask(apples);
	initSensor(&muxedSensor[0], msensor_S2_1, typeMode[0]);
	//sleep(100);
	//initSensor(&muxedSensor[1], msensor_S2_2, typeMode[0]);

	while (true)
	{
		readSensor(&muxedSensor[0]);
		sleep(50);
		//readSensor(&muxedSensor[1]);
		//sleep(50);
		if (apple ==0)
		{
			int n = getDistancefront();
			if(n != 2)
			{
				e =	getIRBeaconChannelDirection(sIr1, 0);
				u = 6*e;
				displayTextLine(4, "e = %d",e);
				displayTextLine(5, " distance = %d",muxedSensor[0].distance);
				motor[mB]= (v1-u) * n * k;
				motor[mA]= (v1+u) * n * k;
				sleep(50);
				readSensor(&muxedSensor[0]);
			}
			else
			{
				motor[mB]= -20;
				motor[mA]= -20;
			}
		}
		//=========================================================================================================================================
		else
		{
			motor[mB]=0;
			motor[mA]=0;
			down();
			nForOut=0;
			sleep(500);


			doorOp();
			sleep(200);
			doorClo();

			sleep(7000);
			doorOp();
			sleep(150);
			doorClo();

			sleep(7000);
			doorOp();
			sleep(150);
			doorClo();

			nForOut=1;
			up();


			sleep(50);
			//readSensor(&muxedSensor[1]);
			//displayTextLine(13, ":%d", muxedSensor[1].distance);
			while (SensorValue[sDisBack] > distocon)
			{
			e =	getIRBeaconChannelDirection(sIr2, 1);
			u = 6*e;
			displayTextLine(4, ":%d", e);
			motor[mA]= k1*(v1-u)*k;
			motor[mB]= k1*(v1+u)*k;
			sleep(50);
			//readSensor(&muxedSensor[1]);
			}

			/*
			sleep(50);
			readSensor(&muxedSensor[1]);
			displayTextLine(13, ":%d", muxedSensor[1].distance);
			while (muxedSensor[1].distance > distocon)
			{
			e =	getIRBeaconChannelDirection(sIr2, 1);
			u = 6*e;
			displayTextLine(4, ":%d", e);
			motor[mA]= k1*(v1-u)*k;
			motor[mB]= k1*(v1+u)*k;
			sleep(50);
			//readSensor(&muxedSensor[1]);
			}
			*/
			//playSound(soundBeepBeep);
			sleep(50);
		}
	}
}
