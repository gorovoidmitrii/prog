#pragma config(Sensor, S1,     sM_Trans,               sensorEV3_GenericI2C)
#pragma config(Sensor, S3,     sColour,        sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S2,     sDis,           sensorSONAR)
#pragma config(Motor,  motorA,          mCon,          tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          mSort,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          mDoor,         tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "mindsensors-ev3smux.h"


// The SMUX can have up to 3 sensors attached to it.
tMSEV3 muxedSensor[2];
tEV3SensorTypeMode typeMode[1] = {infraRedProximity};
// int color = 0;
int t = 0;
int cour = 0;
long redValue;
long greenValue;
long blueValue;
int const min_for_green=10; //max for red 7, min for green 12 -green value
int colorflag = 0;// green =1, red = 0
int const dis = 11;
int disS = 0;
int disflag = 0;


task Con()
{
	while (true)
	{
		if (t==1)
		{
			if (cour == 0)
			{
				motor[mCon]= 20; //run transporter
			}
			else
			{
				motor[mCon]= 0;
			}
		}
		else
		{
			motor[mCon]= 0;
		}
	}
}

void door2_open() //red or yellow
{
	nMotorEncoder[mSort]=0;
	while (nMotorEncoder[mSort] > -53)
	{
		motor[mSort]=-30;
	}
	motor[mSort]=0;
}

void door2_close()
{
	nMotorEncoder[mSort]=0;
	while (nMotorEncoder[mSort] < 53)
	{
		motor[mSort]=30;
	}
	motor[mSort]=0;
}
void door_open()
{
	while (nMotorEncoder[mDoor] < 100)
	{
		motor[mDoor]=30;

	}
	motor[mDoor]=0 ;
	nMotorEncoder[mDoor]=0;

}
void door_close()
{
	nMotorEncoder[mDoor]=0;
	while (nMotorEncoder[mDoor] > -100)
	{
		motor[mDoor]=-30;

	}
	motor[mDoor]=0 ;
	nMotorEncoder[mDoor]=0;

}
task colour()
{
	getColorRGB(sColour, redValue, greenValue, blueValue);
	setSensorMode(sColour,modeEV3Color_Color);
	while(true)
	{
		getColorRGB(sColour, redValue, greenValue, blueValue);
		displayBigTextLine(2, "%f", redValue);
		displayBigTextLine(4, "%f", greenValue);
		displayBigTextLine(6, "%f", blueValue);
		sleep(100);
	}
}

task dis_col()
{
	while(true)
	{
		disS = SensorValue[sDis];
		displayTextLine(9,"%d",disS);
		displayTextLine(10,"%d",disflag);
		if (disS < dis)
		{
			disflag = 1;
		}
		else
		{
			disflag = 0;
		}
	}
}
task cours()
{
	while(true)
	{
		readSensor(&muxedSensor[0]);
		readSensor(&muxedSensor[1]);
		displayTextLine(12, "Distance: %d", muxedSensor[0].distance);
		displayTextLine(13, "Distance: %d", muxedSensor[1].distance);
		sleep(200);
		if (muxedSensor[0].distance <10)
		{
			cour = 1;
		}
		else
		{
			if(	muxedSensor[1].distance <10)
			{
				cour = 1;
			}
			else
			{
				cour = 0;
			}

		}
	}
}
task trans()
{
	while(true)
	{
		if (SensorValue[S4] <10)
		{
			t = 0;
		}
		else
		{
			t = 1;
		}
	}
}

task main()
{
	initSensor(&muxedSensor[1], msensor_S1_2, typeMode[0]);
	initSensor(&muxedSensor[0], msensor_S1_1, typeMode[0]);
	startTask(cours);
	startTask(colour);
	startTask(dis_col);
	startTask(Con);
	while (true)
	{
		wait1Msec(1000);
		if (greenValue < min_for_green)
		{
			colorflag=0;
			door2_open ();
			door_open ();
			wait1Msec(4000);
			door_close ();
			wait1Msec(4000);
			door2_close();
		}
		else
		{
			colorflag=1;
			door_open ();
			wait1Msec(4000);
			door_close ();
		}
	}
}
