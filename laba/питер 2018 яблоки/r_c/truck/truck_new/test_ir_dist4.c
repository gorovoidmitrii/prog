#pragma config(Sensor, S1,     sLeft,    sensorEV3_GenericI2C)
#pragma config(Sensor, S2,     sIr1,           sensorEV3_IRSensor)
#pragma config(Sensor, S3,     sDis,           sensorEV3_Ultrasonic)
#pragma config(Sensor, S4,     sIr2,           sensorEV3_IRSensor)
#pragma config(Motor,  motorA,          mA,            tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          mB,            tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          mOut,          tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          mDoor,         tmotorEV3_Medium, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#include "mindsensors-irdist.h"

int a1 = 11;
int a2 = 1000;
int a3 = 10;
int a4 = 11;
int a5 = 12;
int dv;
int errDist;
int table = 0;
int GoodDist;
int isFarFromTheWall = 0;
int isTransporterNearLeshaAppleLoader = 0;
int appleCheckFlag = 0; //apple check: 0-no apple, 1- apple
int DISTANCE_FROM_SENSOR_sDis = 0;
int distance2CollectorCheckFlag = 0 ;
float howManyDegWeNeed2Turn = 0;

int const DISTANCE_TO_CONVEYER_MIN = 30;
int const DISTANCE_TO_APPLE_LOADER_MIN = 5;//distance to collector min
int const DISTANCE_TO_APPLE_LOADER_MAX = 8;//distance to collector max
int const DISTANCE_TO_APPLE_MIN = 8;
int const DISTANCE_TO_THE_WALL = 28;
int const ENCODERS_360 = 1210;//1040;
int const TEST_LENGHT = 241;

task apples();
void driveTransporter2LeshasAppleLoader();
void followLeshasAppleLoader2LetHimLoadApplesInTransporter();
void transportApples2Conveyer();
void driveTransporter2StartingPlace();
void turnRight();
void turnHelp(float degrees);
void sleepSec(int sec);
void takeError();
void GoFoward();
int sort ();
int min();

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
task main()
{
	table = MSDISTreadDist(sLeft);
	sleep(100);
	GoodDist= MSDISTreadDist(sLeft);
	displayTextLine(2,"%d", GoodDist);
	GoFoward();
	takeError();
	howManyDegWeNeed2Turn = radiansToDegrees( atan2(errDist, TEST_LENGHT));
	turnHelp(howManyDegWeNeed2Turn);

}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void GoFoward()
{
	nMotorEncoder[mA] = 0;
	while (nMotorEncoder[mA]<500)//241
	{
		motor[mA]=20;
		motor[mB]=20;
	}
	motor[mA]=0;
	motor[mB]=0;
}
//-----------------------------------
void takeError()
{
	a1 = MSDISTreadDist(sLeft);
	sleep(100);
	a2 = MSDISTreadDist(sLeft);
	sleep(100);
	a3 = MSDISTreadDist(sLeft);
	sleep(100);
	a4 = MSDISTreadDist(sLeft);
	sleep(100);
	a5 = MSDISTreadDist(sLeft);
	sleep(100);
  errDist = abs(sort()-GoodDist);
}
//-----------------------------------
void turnHelp(float degrees)
{
	float encoders = ENCODERS_360/360*degrees*-1;
	displayTextLine(0,"e = %d", encoders);
	nMotorEncoder[mA] = 0;
	if (GoodDist-dv>=0)
	{
		while (nMotorEncoder[mA] < encoders*-1)
		{
			motor[mA]=20;
			motor[mB]=-20;
		}
		motor[mA]=0;
		motor[mB]=0;
	}
	else
	{
		while (nMotorEncoder[mA]>encoders)
		{
			motor[mA]=-20;
			motor[mB]=20;
		}
	}
	motor[mA]=0;
	motor[mB]=0;
}
//--------------------------------------------------------
int sort ()
{
	int b1,b2,b3;
	b1 = min();
	sleep(100);
	b2 = min();
	sleep(100);
	b3 = min();
	return b3;
	displayTextLine(1, "%d", b3);
}
//----------------------------------------------------------
int min()
{
	int index = 1;
	int minimum = a1;
	//+++++
	if (minimum > a2)
	{
		index = 2;
		minimum = a2;
	}
	//****
	if (minimum > a3)
	{
		index = 3;
		minimum = a3;
	}
	//****
	if (minimum > a4)
	{
		index = 4;
		minimum = a4;
	}
	//****
	if (minimum > a5)
	{
		index = 5;
		minimum = a5;
	}
	//+++++++++++++++++++++++++++++++++++++
	if (index == 1)a1 = 10000;
	//****
	if (index == 2)a2 = 10000;
	//****
	if (index == 3)a3 = 10000;
	//****
	if (index == 4)a4 = 10000;
	//****
	if (index == 5)a5 = 10000;

	return minimum;
}
