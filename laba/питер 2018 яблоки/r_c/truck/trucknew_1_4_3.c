#pragma config(Sensor, S1,     sIr,            sensorEV3_IRSensor, modeEV3IR_Seeker)
#pragma config(Sensor, S2,     sDis,           sensorEV3_IRSensor)
#pragma config(Sensor, S3,     sApple,         sensorSONAR)
#pragma config(Motor,  motorA,          mA,            tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          mB,            tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          mOut,          tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          mDoor,         tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
int e = 0;
int apple = 0;
int n = 0;
int v1 = 20; // nei?inou aey iiai?ioa
int	v2 = 50; // nei?inou aey acau i?yii
int dis = 0;
int dis2 = 0;
void dooro ()
{
	nMotorEncoder[mDoor]=0;
	while(nMotorEncoder[mDoor]<95)
	{
		motor[mDoor]=70;
		sleep(1);
	}

}
void doorc ()
{
	nMotorEncoder[mDoor]=0;
	while(nMotorEncoder[mDoor]>-95)
	{
		motor[mDoor]=-70;
		sleep(1);
	}
}
task distance() //?annoiyiea ai i?aiyonoaey
{
	while (true)
	{
		dis = SensorValue[sDis];
		displayTextLine(5,"%d",dis);
		if(SensorValue[sDis]<30)
		{
			if (SensorValue[sDis]<15)
			{
				n = 1; //oeaa inoaiiaee = noiyou
				v1 = 0; //iaioeaiea nei?inoe
				v2 = 0;
			}
			else
			{
				n = 0;
				v1 = 0;
				v2 = 0;
			}
		}
		else
		{
			n = 0;
			v1 = 20;
			v2 = 50;
		}
	}
}
task apples()
{

	while(true)
	{
		dis2 = SensorValue[sApple];
		displayTextLine(6,"%d",apple);
		displayTextLine(7,"%d",dis2);
		if (SensorValue[sApple]<10)
		{
			sleep(2000);
			if (SensorValue[sApple]<10)
			{
				apple = 1;
			}
		}
		else
		{
			apple = 0;
		}
	}
}



task main()
{
	startTask(distance);
	startTask(apples);

	while(true)
	{
		if ( apple == 0)
		{
			if ( n == 0)
			{                                  // acaa ca eio?ae?aniui iayeii
				//e = getIRBeaconChannelDirection(sIr,2);
				e = getIRBeaconDirection(sIr);
				displayTextLine(4, "%d",e);
				if ( e > 2)
				{
					motor[mB]= -1 * v1;
					motor[mA]= v1;
					sleep(1);
				}
				else if ( e < -2)
				{
					motor[mB]=v1;
					motor[mA]= -1 * v1;
					sleep(1);
				}
				else
				{
					motor[mA]=v2;
					motor[mB]=v2;
					sleep(1);
				}
			}
			else
			{// neeoeii iaeaiueia ?annoiyiea, iaai iouaoaou
				motor[mB]=v2;
				motor[mA]=v2;
				sleep(1);
				nMotorEncoder[mB]=0;
				while (nMotorEncoder[mB]>-500)
				{
					motor[mB]=-50;
					motor[mA]=-50;
					sleep(1);
				}
			}
		}
		else
		{//aua?ocea yaeiea
			motor[mB]=v2;
			motor[mA]=v2;
			sleep(1);
			nMotorEncoder[mB]=0;
			while (nMotorEncoder[mB]>-500)
			{
				motor[mB]=-50;
				motor[mA]=-50;
				sleep(1);

			}
			motor[mB]=v2;
			motor[mA]=v2;
			nMotorEncoder[mOut]=0;
			while (nMotorEncoder[mOut]>-2500)
			{
				motor[mOut]= -100;

				wait1Msec(1);
			}
			motor[mOut]=0;
			dooro ();

			doorc();

			nMotorEncoder[mOut]=0;
			while (nMotorEncoder[mOut]<2500)
			{
				motor[mOut]=  100;

				wait1Msec(1);
			}
			motor[mOut]=0;


		}

	}

}
