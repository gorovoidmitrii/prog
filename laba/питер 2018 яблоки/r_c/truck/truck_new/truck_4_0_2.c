#pragma config(Sensor, S1,     sIr,            sensorEV3_IRSensor, modeEV3IR_Seeker)
#pragma config(Sensor, S2,     sDis,           sensorEV3_IRSensor)
#pragma config(Sensor, S3,     sApple,         sensorSONAR)
#pragma config(Motor,  motorA,          mA,            tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          mB,            tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          mOut,          tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          mDoor,         tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
int e = 0;
int u = 0;
int apple = 0; //apple check: 0-no apple, 1- apple
int n = 0;//distance check flag: 0- stop, 1 - go, 2 - go back
int const v1 = 50; // speed main
int	const v2 = 30; // speed slow
int disS = 0;
int const dis2 = 20;//distance to collector min
int const dis1 = 40;//distance to collector max
float const k = 0.2;//slow speed value




task distance()
{
	while (true)
	{
		disS = SensorValue[sDis];
		displayTextLine(5,"%d",disS);
		if(SensorValue[sDis]<dis1)
		{
			if (SensorValue[sDis]<dis2)
			{
				n = 2;

			}
			else
			{
				n = 0;


			}
		}
		else
		{
			n = 1;

		}
	}
}



task main()
{
	startTask(distance);
	while (true)
	{
		if ( apple == 0)
		{
			if ( n != 2 )
			{
				e = getIRBeaconDirection(sIr);
				u = 6*e;
				displayTextLine(4, "%d",e);

				motor[mB]= (v1-u)*n*k;
				motor[mA]= (v1+u)*n*k;
				sleep(1);
			}
			else
			{//
				motor[mB]=0;
				motor[mA]=0;
				sleep(1);
				nMotorEncoder[mB]=0;
				while (nMotorEncoder[mB]>-500)
				{
					motor[mB]=-20;
					motor[mA]=-20;
					sleep(1);
				}
			}
		}
	}
}
